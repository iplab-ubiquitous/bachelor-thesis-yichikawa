\chapter{実装}\chaLabel{implementation}
\section{概要}
\SysName は，ハードウェアとして三角法を用いた光学式距離センサ10個を一列に並べたセンサアレイと，センサから取得した値の処理と値を元に座標を計算するソフトウェアからなる．
\section{プロトタイプ} 
\secLabel{proto1}
\subsection{ハードウェア}
距離センサはSHARP GP2Y0E03\footnote{http://www.sharp.co.jp/products/device/lineup/selection/opto/haca/diagram2.html}を使用した．この距離センサは三角測量の原理を用い，対象までの距離を計測する．本センサの値の取得には，Arduino MEGA 2560を用いる．距離センサとは\iic を用いて接続を行う．個々のセンサは，スレーブアドレスが初期値(0x40)で統一されているために，アプリケーションノート\footnote{http://www.sharp.co.jp/products/device/doc/opto/gp2y0e02\_03\_appl\_j.pdf}に記載されているe-fuseプログラミングの手順で，スレーブアドレスの変更を行なっている．これにより，10個の距離センサを2本の信号線で制御する．
接続した距離センサは1列に並べる．\SysName では，長さ約30\si{cm}のプラスティック製の定規を用意し，両面テープでセンサ本体を固定し，配線類をセロハンテープで固定した．装置が長細いため，接続にはブレッドボードの電源とグランド接続に用いられる部分を2列使用した．\refImg{ig1}は実際に製作したプロトタイプの1つである．\refImg{im1}ではセンサごとの間隔は約11\si{mm}としている．
\img{htbp}{1}{IMG_1794.jpg}{プロトタイプその1}{im1}

Arduinoでは，\iic による制御を行い，値をシリアルモニタに送信することだけを行う．したがって，センサのノイズ等の処理は全てソフトウェアで行う．
\subsection{ソフトウェア} 
プログラム言語はPythonを用いた．シリアル通信のためのライブラリとしてPySerial，ポインタを描画するGUIのためのライブラリとしてPyQtを用いた．
膝の位置の計算には，スマートウォッチに搭載した距離センサから指の位置をトラッキングしたXiaoら\cite{Xiao:2018:LOP:3173574.3173669}の研究を参考にした．膝の位置の計算は次のように行う．
\begin{enumerate}
	\item センサからの値を指数平均平滑フィルタを用いて平滑化する．
	\item $y$軸方向の位置をすべての距離センサの最小値とする．
		\begin{eqnarray}
		 	y = min(sensors\_val)
		 	\label{formula:f1}
		\end{eqnarray}
	\item $i$番目の距離センサについて，重み$w_i$を式\ref{formula:f2}のように計算する．ここで，$d$は重み調整の定数である．\SysName では調整の結果$d=2$としている．
		\begin{eqnarray}
			w_i = \cfrac{1}{y_i - y + d}
		\label{formula:f2}
	\end{eqnarray}
	\item $w_i$から，$x$座標を式\ref{formula:f3}のように計算する．
		\begin{eqnarray}
		 	x =\cfrac{\sum iw_i}{\sum w_i}
		 	\label{formula:f3}
		\end{eqnarray} 
	\item ($x,y$)を指数平均平滑フィルタを用いて平滑化する．
	\item ($x,y$)を実際のディスプレイの画面サイズに合わせてマッピングする．
\end{enumerate}
使用者はあらかじめ上下左右方向にキャリブレーションを行い，膝の可動範囲の限界を記録し，これを元に6.のマッピングが行われる．

\subsection{プロトタイプ1の性能評価}\subsecLabel{proto1_problem}
実装を行なったプロトタイプを机の裏に設置し，自由なポインタの操作ができるか試みた．キャリブレーション次第では膝を静止させた時にポインタも静止するが，多くの場合は膝を静止させているにも関わらずポインタは左右に振れるなどした．センサからの値を観察したところ，\fixme{膝がかかっていない部分の値}が激しく上下していることがわかった．原因として，以下のようなものが挙げられた．
\begin{enumerate}
	\item アプリケーションノートに，移動物体に対するセンサの設置方向に関する記述があり，センサの設置方向が正しくない可能性がある．プロトタイプ1では\refImg{im2}の黒い矢印の方向に膝が移動するが，赤い矢印の方向で移動する必要がある．
	\item センサのコネクタのピンが細いため，ブレッドボード接続をしたことにより接触不良を起こしている．
	\item 床の色が黒く，赤外線を吸収し正しく距離を計測できていない．
	\item \fixme{センサの設置部分が小さく，膝が範囲外に飛び出してしまう}
\end{enumerate}
\img{htbp}{1}{proto2-1}{移動物体に対する距離センサの設置方向概念図}{im2}
\section{プロトタイプ2}
\subsection{改良点}
\refSubsec{proto1_problem}であげた問題を解決するために，プロトタイプに改良を行った．
\begin{itemize}
	\item{改良1: } 問題点1.について，すべてのセンサを90度左回転させて設置した．また同時に問題点4.について，左右方向に膝を傾けた時にどれくらいの範囲を動くかを測定し，必要なセンサのカバー範囲を推定した．測定の結果，におよそ20〜30\si{cm}の長さが必要であるとわかった．このことから，センサの間隔を11\si{mm}から30\si{mm}に変更し再配置した．
	\item{改良2: } 問題点2.について，実装を\fixme{ブレッドボードでの接続からユニバーサル基板を用いて配線を固定すること}とした．
	\item{改良3: } 問題点3.について，センサの直下には床に白紙を貼り付けることで解決を図った．
\end{itemize}

\subsection{改良後の評価}
改良1を加えたプロトタイプ2を同様に机の裏に設置し，自由なポインタの操作ができるか実験した．プロトタイプ1ではポインタの左右の振れ方はとても大きく，キャリブレーション次第では操作もままならないほどであったが，改良1により軽減された．問題点1.の指摘は正しく，改良後のセンサの配置方向が正しいと考えられる．しかし，依然としてポインタが左右に振れた．
\par
改良2を加えて同様の実験を行なったところ，ポインタの左右の振れの改善はあまり見られなかった．これは，\fixme{センサと膝は直接触れることはないため，設置した状態から動くことはないからであると考える．}しかし，ユニバーサル基盤上に実装したことで，接続部分がブレッドボードよりも薄くなり机裏への設置が容易になった．加えてプロトタイプ1では作業中に簡単に配線が抜けてしまうことがあったが，配線が固定され抜けることがなくなった．したがって，ブレッドボードの実装に戻すことはしなかった．
\par
改良3を加えて，まずセンサの値を観察したところ，相変わらずノイズは観察されるが，指数平均平滑フィルタを通した後の値は改良3を加える前よりも安定した．床面を白くすることで赤外線の反射が多くなり，正しく測定できているからであると考える．

