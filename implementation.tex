\chapter{膝位置認識とカーソル座標計算を行う\\プロトタイプの実装}\chaLabel{implementation}
\section{概要}
本章では，膝の位置を認識し，マウスカーソルに適用するプロトタイプの実装について述べる．プロトタイプは，三角法を用いた光学式距離センサ10個を一列に並べたセンサアレイ，マイコン，パーソナルコンピュータからなるハードウェアと，センサから距離データを取得し，フィルタ処理，膝の位置の計算を行うソフトウェアからなる．\refImg{proto_outline}に，プロトタイプの概要を示す．
\img{htbp}{1.0}{proto_outline.pdf}{プロトタイプの概念図}{proto_outline}

プロトタイプによる膝の位置認識と，カーソル座標への変換の流れは以下のようになっている．
\begin{enumerate}
	\item ユーザは机の裏に距離センサアレイを設置し，パーソナルコンピュータと接続する．そして，膝を上下左右に動かす．
	\item 距離センサアレイが，各センサと膝との距離を計測する．
	\item 全ての距離センサの計測値は膝位置計算ソフトウェアに送信される．
	\item ソフトウェアは，膝の位置を計算し、カーソル座標を計算する．\\ソフトウェアの詳細な流れを以下に示す．
	\begin{enumerate}
		\item 計測値を指数移動平均フィルタにかける．
		\item 机に垂直な面において膝がどの位置にあるかを計算する．
		\item キャリブレーションにより，ユーザの膝が移動できる範囲を記録する．
		\item キャリブレーション時の値とマウスカーソルを描画するディスプレイの解像度からカーソル座標を計算する．
	\end{enumerate}
\end{enumerate}
この時ユーザは机の裏に距離センサアレイを設置し，パーソナルコンピュータとの接続のみを行い，膝には何も装着しない．

\section{ハードウェア}\secLabel{proto1}
距離センサはSHARP GP2Y0E03\footnote{http://www.sharp.co.jp/products/device/lineup/selection/opto/haca/diagram2.html}を使用した．この距離センサは三角測量の原理を用い，対象までの距離を計測する．個々のセンサは，スレーブアドレスが初期値(0x40)で統一されているために，アプリケーションノート\footnote{http://www.sharp.co.jp/products/device/doc/opto/gp2y0e02\_03\_appl\_j.pdf}に記載されているe-fuseプログラミングの手順で，スレーブアドレスの変更を行なった．
\SysName では，長さ約30\si{cm}のプラスティック製の定規に，両面テープでセンサ本体を30\si{mm}間隔で定規に固定し，配線類はセロハンテープで固定した．
%30\si{mm}という間隔は，センサアレイが膝が左右に動く範囲を全てカバーできる範囲として設定した．
\refImg{im1}は実際に製作したプロトタイプの一部である．
距離センサは横向きにして1列に並べた．これは，GP2Y0E03のアプリケーションノート\footnotemark[2]には，センサを物体の移動方向が\refImg{im2}の黒い矢印の方向ではなく，赤い矢印の方向になるように設置する方が，誤差が少ないためである．
\par
個々の距離センサはArduino MEGA 2560（Arduino）ユニバーサル基板を介して接続される．\iic 通信を用いて，Arduinoが距離センサの値を読み取る．ArduinoはパーソナルコンピュータとUSBで接続され，シリアル通信を用いて，10個の距離データをひとまとめにしたものを1フレームとして，Arduinoからパーソナルコンピュータへ送信する．
\img{htbp}{0.95}{proto.pdf}{製作したプロトタイプの一部}{im1}
\img{htbp}{0.5}{proto2-1}{移動物体に対する距離センサの設置方向}{im2}
\section{膝の位置の計算} 
膝の位置の計算には，
%スマートウォッチに搭載した距離センサから指の位置をトラッキングした
Xiaoら\cite{Xiao:2018:LOP:3173574.3173669}の方法を参考にした．ソフトウェアでは，以下の4点を行う．
\begin{itemize}
	\item シリアル通信で受信した距離データを指数移動平均フィルタにかける．
	\item 膝の位置を計算する．
	\item キャリブレーションを行う．
	\item 膝の位置をマウスカーソルの座標に変換する．
\end{itemize}
プログラム言語はPythonを用いた．シリアル通信のためのライブラリとしてPySerial，ポインタを描画するGUIのためのライブラリとしてPyQtを用いた．
\subsection{指数移動平均フィルタ}
指数移動平均フィルタは，時間の経過とともに重みを指数関数的に減少させるフィルタである．最新のデータを重視する一方で，古いデータについても考慮に入れるという特徴を持つ．重みの減少度合いは平滑化係数$\alpha$を用いて表される．本プロトタイプでは，調整の結果$\alpha = 0.1, 0.65$の2つを使用している．時間$t$の距離データ$s^t$に対しフィルタリング後の値$D^t$を以下のように計算し，フィルタを実装した．
\begin{eqnarray}
	D^t = \alpha (s^t - D^{t-1}) + D^{t-1}
\end{eqnarray}
\subsection{膝位置認識}
\subsecLabel{acq}
時間$t$における膝の位置$(K^t_x, K^t_y)$を次のように計算する．
\begin{enumerate}
	\item 各距離センサの値を$\alpha=0.1$の指数移動平均フィルタにかける．これを$D^t_i$と表す．ただし，$i$は距離センサの番号を表し，\refImg{im1}の一番左の距離センサから順に$i=0,1,..9$と番号を振ることとする．
	\item $K^t_y$を$D^t_i $の最小値とする．
		\begin{eqnarray}
		 	K^t_y = \min_i(D^t_i)
		 	\label{formula:f1}
		\end{eqnarray}
	\item $i$番目の距離センサについて，重み$w_i$を式\ref{formula:f2}のように計算する．ここで，$d$は重み調整の定数である．\SysName では調整の結果$d=2$としている．
		\begin{eqnarray}
			w_i = \cfrac{1}{D^t_i - K^t_y + d}
		\label{formula:f2}
	\end{eqnarray}
	\item $w_i$から，$K^t_x$を計算する．
		\begin{eqnarray}
		 	 K^t_x=\cfrac{\sum_i iw_i}{\sum_i w_i}
		 	\label{formula:f3}
		\end{eqnarray} 
	\item 得られた$(K^t_x, K^t_y)$を$\alpha=0.65$の指数移動平均フィルタにかける．
\end{enumerate}
\section{膝の位置からカーソル座標への変換}
\subsection{キャリブレーション}
\subsecLabel{cal}
\refSubsec{acq}で行なった，時間$t$の膝の位置をマウスカーソルの座標に変換するために，キャリブレーションとしてユーザの膝の位置を記録する．キャリブレーションは，ユーザが膝を動かす上下左右の限界点と，マウスカーソルがディスプレイの中心にある時の膝の位置の5点で行う．
%膝の位置の計算には指数移動平均フィルタを使っているため，最初の数フレームは実際とは異なる値が出力されてしまう．そのため，
得られた上下左右および真ん中の点を$(C_{upper}, C_{lower}, C_{left}, C_{right}, (C_{center_x}, C_{center_y}))$と表す．
\subsection{カーソル座標への適用}
\refSubsec{acq}で計算された時間$t$における膝の位置$(K^t_x, K^t_y)$を，\refSubsec{cal}で得たキャリブレーションをもとに，パーソナルコンピュータのディスプレイ上のカーソル座標$(P^t_x, P^t_y)$へと次のように変換する．なお，ここでは解像度が$(W_x, W_y)$のディスプレイを想定している．
\begin{eqnarray}
	P^t_x = 
	\begin{cases}
		\cfrac{(K^t_x - C_{left}) \left( \cfrac{W_x}{2} \right)}{C_{center_x} - C_{left}} & (K^t_x < C_{center_x})\\
		\cfrac{(K^t_x - C_{center_x}) \left( \cfrac{W_x}{2} \right)}{C_{right} - C_{center_x}} & (C_{center_x} \leq K^t_x)
	\end{cases}	 
\end{eqnarray}
\begin{eqnarray}
	P^t_y = 
	\begin{cases}
		\cfrac{(K^t_y - C_{upper}) \left( \cfrac{W_x}{2} \right)}{C_{center_y} - C_{upper}} & (K^t_y < C_{center_y}) \\
		\cfrac{(K^t_x - C_{center_y}) \left( \cfrac{W_x}{2} \right)}{C_{lower} - C_{center_y}} & (C_{center_y} \leq K^t_y)
	\end{cases}
\end{eqnarray}


%\subsection{プロトタイプ1の性能評価}\subsecLabel{proto1_problem}
%実装を行なったプロトタイプを机の裏に設置し，自由なポインタの操作ができるか試みた．キャリブレーション次第では膝を静止させた時にポインタも静止するが，多くの場合は膝を静止させているにも関わらずポインタは左右に振れるなどした．センサからの値を観察したところ，\fixme{膝がかかっていない部分の値}が激しく上下していることがわかった．原因として，以下のようなものが挙げられた．

%\section{プロトタイプ2}
%\subsection{改良点}
%\refSubsec{proto1_problem}であげた問題を解決するために，プロトタイプに改良を行った．
%\begin{itemize}
	%\item{改良1: } 問題点1.について，すべてのセンサを90度左回転させて設置した．また同時に問題点4.について，
	%\item{改良2: } 問題点2.について，実装を\fixme{ブレッドボードでの接続からユニバーサル基板を用いて配線を固定すること}とした．
	%\item{改良3: } 問題点3.について，センサの直下には床に白紙を貼り付けることで解決を図った．
%\end{itemize}

%\subsection{改良後の評価}
%改良1を加えたプロトタイプ2を同様に机の裏に設置し，自由なポインタの操作ができるか実験した．プロトタイプ1ではポインタの左右の振れ方はとても大きく，キャリブレーション次第では操作もままならないほどであったが，改良1により軽減された．問題点1.の指摘は正しく，改良後のセンサの配置方向が正しいと考えられる．しかし，依然としてポインタが左右に振れた．
%\par
%改良2を加えて同様の実験を行なったところ，ポインタの左右の振れの改善はあまり見られなかった．これは，\fixme{センサと膝は直接触れることはないため，設置した状態から動くことはないからであると考える．}しかし，ユニバーサル基盤上に実装したことで，接続部分がブレッドボードよりも薄くなり机裏への設置が容易になった．加えてプロトタイプ1では作業中に簡単に配線が抜けてしまうことがあったが，配線が固定され抜けることがなくなった．したがって，ブレッドボードの実装に戻すことはしなかった．
%\par
%改良3を加えて，まずセンサの値を観察したところ，相変わらずノイズは観察されるが，指数平均平滑フィルタを通した後の値は改良3を加える前よりも安定した．床面を白くすることで赤外線の反射が多くなり，正しく測定できているからであると考える．

